/******/ // The require scope
/******/ var __lib_require__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ !function() {
/******/ 	// define getter functions for harmony exports
/******/ 	__lib_require__.d = function(exports, definition) {
/******/ 		for(var key in definition) {
/******/ 			if(__lib_require__.o(definition, key) && !__lib_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ }();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ !function() {
/******/ 	__lib_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ }();
/******/ 
/************************************************************************/
var __lib_exports__ = {};

// EXPORTS
__lib_require__.d(__lib_exports__, {
  "AuthManager": function() { return /* reexport */ AuthManager; },
  "BaseAPI": function() { return /* reexport */ BaseAPI; },
  "BinaryResult": function() { return /* reexport */ BinaryResult; },
  "BytescaleApiClientConfigUtils": function() { return /* reexport */ BytescaleApiClientConfigUtils; },
  "BytescaleApiError": function() { return /* reexport */ BytescaleApiError; },
  "BytescaleGenericError": function() { return /* reexport */ BytescaleGenericError; },
  "CancelledError": function() { return /* reexport */ CancelledError; },
  "CommonTypesNoOp": function() { return /* reexport */ CommonTypesNoOp; },
  "FileApi": function() { return /* reexport */ FileApi; },
  "FolderApi": function() { return /* reexport */ FolderApi; },
  "JSONApiResponse": function() { return /* reexport */ JSONApiResponse; },
  "JobApi": function() { return /* reexport */ JobApi; },
  "UploadApi": function() { return /* reexport */ UploadApi; },
  "UploadManager": function() { return /* reexport */ UploadManager; },
  "UrlBuilder": function() { return /* reexport */ UrlBuilder; },
  "UrlBuilderTypesNoOp": function() { return /* reexport */ UrlBuilderTypesNoOp; },
  "VoidApiResponse": function() { return /* reexport */ VoidApiResponse; },
  "encodeBytescaleQuerystringKVP": function() { return /* reexport */ encodeBytescaleQuerystringKVP; },
  "querystring": function() { return /* reexport */ querystring; }
});

;// CONCATENATED MODULE: ./src/private/FairMutex.ts
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _call(body, then, direct) {
  if (direct) {
    return then ? then(body()) : body();
  }
  try {
    var result = Promise.resolve(body());
    return then ? result.then(then) : result;
  } catch (e) {
    return Promise.reject(e);
  }
}
function _rethrow(thrown, value) {
  if (thrown) throw value;
  return value;
}
function _finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }
  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }
  return finalizer(false, result);
}
function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function _empty() {}
function _awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(_empty) : Promise.resolve();
  }
}
function _invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * A lightweight fair mutex. (Other libraries contain too many features and we want to keep size down).
 *
 * Characteristics:
 * - Non-reentrant.
 * - Fair.
 *   - This means multiple callers awaiting 'lock' will be granted the mutex in the order they requested it.
 *   - This is important, as in React, developers calling 'AuthManager.endAuthSession' in a 'useEffect' cleanup need it
 *     to take effect immediately, such that subsequent 'AuthManager.beginAuthSession' calls will always succeed.
 *   - When calling `safe` consecutively with no 'awaits' in-between, the current context will synchronously acquire
 *     the mutex every time.
 */
var FairMutex = /*#__PURE__*/function () {
  function FairMutex() {
    _classCallCheck(this, FairMutex);
    this.locked = false;
    this.queue = [];
  }
  _createClass(FairMutex, [{
    key: "safe",
    value: function safe(callback) {
      try {
        var _this2 = this;
        return _await(_this2.lock(), function () {
          return _finallyRethrows(callback, function (_wasThrown, _result) {
            _this2.unlock();
            return _rethrow(_wasThrown, _result);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "lock",
    value: function lock() {
      try {
        var _exit2 = false;
        var _this4 = this;
        return _invoke(function () {
          if (_this4.locked) {
            var unlockNext;
            var lockPromise = new Promise(function (resolve) {
              unlockNext = resolve;
            });
            if (unlockNext === undefined) {
              throw new Error("unlockNext was undefined");
            }
            _this4.queue.push({
              resolve: unlockNext
            });
            return _awaitIgnored(lockPromise);
          }
        }, function (_result2) {
          if (_exit2) return _result2;
          _this4.locked = true;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "unlock",
    value: function unlock() {
      if (!this.locked) {
        throw new Error("Mutex is not locked.");
      }
      var nextInQueue = this.queue.shift();
      if (nextInQueue !== undefined) {
        nextInQueue.resolve();
      } else {
        this.locked = false;
      }
    }
  }]);
  return FairMutex;
}();
;// CONCATENATED MODULE: ./src/private/AuthSessionState.ts
function AuthSessionState_typeof(obj) { "@babel/helpers - typeof"; return AuthSessionState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AuthSessionState_typeof(obj); }
function AuthSessionState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function AuthSessionState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, AuthSessionState_toPropertyKey(descriptor.key), descriptor); } }
function AuthSessionState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AuthSessionState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AuthSessionState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function AuthSessionState_toPropertyKey(arg) { var key = AuthSessionState_toPrimitive(arg, "string"); return AuthSessionState_typeof(key) === "symbol" ? key : String(key); }
function AuthSessionState_toPrimitive(input, hint) { if (AuthSessionState_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (AuthSessionState_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

/**
 * Maintains a global session state, even across package versions.
 *
 * This is to allow users to start auth sessions via the Bytescale JavaScript SDK, where due to versioning or other
 * bundling issues, the Bytescale Upload Widget has been bundled with a different Bytescale JavaScript SDK. In this
 * scenario, the user wouldn't be able to start an auth session with the Bytescale Upload Widget. Therefore, we use
 * global state (i.e. on the window) to ensure the session state can be shared between the user's instance of the
 * Bytescale JavaScript SDK and the Upload Widget's version of the Bytescale JavaScript SDK.
 *
 * Users also frequently have problems caused by them not keeping track of *Api and *Manager instances correctly, so
 * making this global prevents a lot of common mistakes.
 */
var AuthSessionState = /*#__PURE__*/function () {
  function AuthSessionState() {
    AuthSessionState_classCallCheck(this, AuthSessionState);
  }
  AuthSessionState_createClass(AuthSessionState, null, [{
    key: "getMutex",
    value:
    /**
     * Called in the browser only.
     */
    function getMutex() {
      var key = AuthSessionState.mutexKey;
      var mutex = window[key];
      if (mutex === undefined) {
        mutex = new FairMutex();
        window[key] = mutex;
      }
      return mutex;
    }
    /**
     * Called in the browser only.
     */
  }, {
    key: "setSession",
    value: function setSession(session) {
      window[AuthSessionState.stateKey] = session;
    }
    /**
     * Called in the browser and in Node.js (so we check the env before calling env-specific code).
     */
  }, {
    key: "getSession",
    value: function getSession() {
      if (typeof window === "undefined") {
        return undefined;
      }
      return window[AuthSessionState.stateKey];
    }
  }]);
  return AuthSessionState;
}();
AuthSessionState.stateKey = "BytescaleSessionState";
AuthSessionState.mutexKey = "BytescaleSessionStateMutex";
;// CONCATENATED MODULE: ./src/private/ConsoleUtils.ts
function ConsoleUtils_typeof(obj) { "@babel/helpers - typeof"; return ConsoleUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ConsoleUtils_typeof(obj); }
function ConsoleUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function ConsoleUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ConsoleUtils_toPropertyKey(descriptor.key), descriptor); } }
function ConsoleUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) ConsoleUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) ConsoleUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function ConsoleUtils_toPropertyKey(arg) { var key = ConsoleUtils_toPrimitive(arg, "string"); return ConsoleUtils_typeof(key) === "symbol" ? key : String(key); }
function ConsoleUtils_toPrimitive(input, hint) { if (ConsoleUtils_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ConsoleUtils_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ConsoleUtils = /*#__PURE__*/function () {
  function ConsoleUtils() {
    ConsoleUtils_classCallCheck(this, ConsoleUtils);
  }
  ConsoleUtils_createClass(ConsoleUtils, null, [{
    key: "debug",
    value: function debug(message) {
      console.log(ConsoleUtils.prefix(message));
    }
  }, {
    key: "warn",
    value: function warn(message) {
      console.warn(ConsoleUtils.prefix(message));
    }
  }, {
    key: "error",
    value: function error(message) {
      console.error(ConsoleUtils.prefix(message));
    }
  }, {
    key: "prefix",
    value: function prefix(message) {
      return "[bytescale-sdk] ".concat(message);
    }
  }]);
  return ConsoleUtils;
}();
;// CONCATENATED MODULE: ./src/public/shared/generated/runtime.ts
function runtime_typeof(obj) { "@babel/helpers - typeof"; return runtime_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, runtime_typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (runtime_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function runtime_empty() {}
function _continue(value, then) {
  return value && value.then ? value.then(then) : then(value);
}
function runtime_invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function _defineProperty(obj, key, value) { key = runtime_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function runtime_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function runtime_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function runtime_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, runtime_toPropertyKey(descriptor.key), descriptor); } }
function runtime_createClass(Constructor, protoProps, staticProps) { if (protoProps) runtime_defineProperties(Constructor.prototype, protoProps); if (staticProps) runtime_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function runtime_toPropertyKey(arg) { var key = runtime_toPrimitive(arg, "string"); return runtime_typeof(key) === "symbol" ? key : String(key); }
function runtime_toPrimitive(input, hint) { if (runtime_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (runtime_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


var BytescaleApiClientConfigUtils = /*#__PURE__*/function () {
  function BytescaleApiClientConfigUtils() {
    runtime_classCallCheck(this, BytescaleApiClientConfigUtils);
  }
  runtime_createClass(BytescaleApiClientConfigUtils, null, [{
    key: "getApiUrl",
    value: function getApiUrl(config) {
      var _a;
      return (_a = config.apiUrl) !== null && _a !== void 0 ? _a : BytescaleApiClientConfigUtils.defaultApiUrl;
    }
  }, {
    key: "getCdnUrl",
    value: function getCdnUrl(config) {
      var _a;
      return (_a = config.cdnUrl) !== null && _a !== void 0 ? _a : BytescaleApiClientConfigUtils.defaultCdnUrl;
    }
  }, {
    key: "getFetchApi",
    value: function getFetchApi(config) {
      var _a;
      return (_a = config.fetchApi) !== null && _a !== void 0 ? _a : fetch;
    }
  }, {
    key: "getAccountId",
    value: function getAccountId(config) {
      var _a, _b;
      var accountId;
      if (BytescaleApiClientConfigUtils.specialApiKeys.includes(config.apiKey)) {
        accountId = BytescaleApiClientConfigUtils.specialApiKeyAccountId;
      } else {
        accountId = (_b = (_a = config.apiKey.split("_")[1]) === null || _a === void 0 ? void 0 : _a.substr(0, BytescaleApiClientConfigUtils.accountIdLength)) !== null && _b !== void 0 ? _b : "";
        if (accountId.length !== BytescaleApiClientConfigUtils.accountIdLength) {
          throw new Error("Invalid Bytescale API key.");
        }
      }
      return accountId;
    }
  }, {
    key: "validate",
    value: function validate(config) {
      var _a;
      // Defensive programming, for users not using TypeScript. Mainly because this is used by UploadWidget users.
      if ((config !== null && config !== void 0 ? config : undefined) === undefined) {
        throw new Error("Config parameter required.");
      }
      if (((_a = config.apiKey) !== null && _a !== void 0 ? _a : undefined) === undefined) {
        throw new Error("Please provide an API key via the 'apiKey' config parameter.");
      }
      if (config.apiKey.trim() !== config.apiKey) {
        // We do not support API keys with whitespace (by trimming ourselves) because otherwise we'd need to support this
        // everywhere in perpetuity (since removing the trimming would be a breaking change).
        throw new Error("API key needs trimming (whitespace detected).");
      }
      // This performs futher validation on the API key...
      BytescaleApiClientConfigUtils.getAccountId(config);
    }
  }]);
  return BytescaleApiClientConfigUtils;
}();
BytescaleApiClientConfigUtils.defaultApiUrl = "https://api.bytescale.com";
BytescaleApiClientConfigUtils.defaultCdnUrl = "https://upcdn.io";
BytescaleApiClientConfigUtils.specialApiKeys = ["free", "demo"];
BytescaleApiClientConfigUtils.specialApiKeyAccountId = "W142hJk";
BytescaleApiClientConfigUtils.accountIdLength = 7; // Sync with: upload/shared/**/AccountIdUtils
/**
 * This is the base class for all generated API classes.
 */
var BaseAPI = /*#__PURE__*/function () {
  function BaseAPI(config) {
    runtime_classCallCheck(this, BaseAPI);
    this.config = config;
    BytescaleApiClientConfigUtils.validate(config);
  }
  /**
   * Returns a successful response (2**) else throws an error.
   */
  runtime_createClass(BaseAPI, [{
    key: "request",
    value: function request(context, initOverrides, baseUrlOverride) {
      try {
        var _this2 = this;
        var _a;
        var apiKey = _this2.config.apiKey;
        context.headers["Authorization"] = "Bearer ".concat(apiKey); // authorization-header authentication
        var session = AuthSessionState.getSession();
        if ((session === null || session === void 0 ? void 0 : session.accessToken) !== undefined) {
          context.headers["Authorization-Token"] = session.accessToken;
        }
        // Key: any possible value for 'baseUrlOverride'
        // Value: user-overridden value for that base URL from the config.
        var nonDefaultBasePaths = _defineProperty({}, BytescaleApiClientConfigUtils.defaultCdnUrl, BytescaleApiClientConfigUtils.getCdnUrl(_this2.config));
        return runtime_await(_this2.createFetchParams(context, initOverrides, baseUrlOverride === undefined ? undefined : (_a = nonDefaultBasePaths[baseUrlOverride]) !== null && _a !== void 0 ? _a : baseUrlOverride), function (_ref) {
          var url = _ref.url,
            init = _ref.init;
          return BaseAPI.fetch(url, init, Object.assign(Object.assign({}, _this2.config), {
            isBytescaleApi: true
          }));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "encodeParam",
    value: function encodeParam(paramName, paramValue) {
      if (paramName === "filePath") {
        if (!paramValue.startsWith("/")) {
          // Non-obvious errors are returned by the Bytescale CDN if forward slashes are omitted, so catch it client-side:
          throw new Error("The 'filePath' parameter must begin with a '/' character.");
        }
        // We must not encode the filePath param (as slashes are valid).
        return paramValue;
      }
      return encodeURIComponent(paramValue);
    }
  }, {
    key: "createFetchParams",
    value: function createFetchParams(context, initOverrides, baseUrlOverride) {
      try {
        var _this4 = this;
        var url = (baseUrlOverride !== null && baseUrlOverride !== void 0 ? baseUrlOverride : BytescaleApiClientConfigUtils.getApiUrl(_this4.config)) + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
          // only add the querystring to the URL if there are query parameters.
          // this is done to avoid urls ending with a "?" character which buggy webservers
          // do not handle correctly sometimes.
          url += "?" + querystring(context.query);
        }
        var configHeaders = _this4.config.headers;
        var _Object$assign3 = Object.assign({}, context.headers);
        return runtime_await(configHeaders === undefined ? {} : typeof configHeaders === "function" ? configHeaders() : configHeaders, function (_configHeaders) {
          var headers = Object.assign(_Object$assign3, configHeaders === undefined ? _configHeaders : _configHeaders);
          Object.keys(headers).forEach(function (key) {
            return headers[key] === undefined ? delete headers[key] : {};
          });
          var initOverrideFn = typeof initOverrides === "function" ? initOverrides : function () {
            return runtime_await(initOverrides);
          };
          var initParams = {
            method: context.method,
            headers: headers,
            body: context.body
          };
          var _Object$assign2 = Object.assign({}, initParams);
          return runtime_await(initOverrideFn({
            init: initParams,
            context: context
          }), function (_initOverrideFn) {
            var overriddenInit = Object.assign(_Object$assign2, _initOverrideFn);
            var init = Object.assign(Object.assign({}, overriddenInit), {
              body: JSON.stringify(overriddenInit.body)
            });
            return {
              url: url,
              init: init
            };
          });
        }, configHeaders === undefined || !(typeof configHeaders === "function"));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }], [{
    key: "fetch",
    value: function fetch(url, init, config) {
      try {
        var _exit3 = false;
        var _a, _b;
        var response;
        return _continue(_catch(function () {
          return runtime_await(BytescaleApiClientConfigUtils.getFetchApi(config)(url, Object.assign(Object.assign({}, init), {
            // This is specifically added to cater for Next.js's Fetch implementation, which caches POST requests...
            //
            // "fetch requests that use the POST method are also automatically cached."
            // - https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#caching-data
            //
            // However, this is probably a good idea, even for all GET requests, as if the user is refreshing a JWT
            // or downloading a file via 'FileApi.downloadFile', then they'll likely want the latest.
            cache: "no-store"
          })), function (_BytescaleApiClientCo) {
            response = _BytescaleApiClientCo;
          });
        }, function (e) {
          // Network-level errors, CORS errors, or HTTP-level errors from intermediary services (e.g. AWS or the user's own infrastructure/proxies).
          // HTTP-level errors from external services (e.g. AWS or the user's own proxy) will appear as CORS errors as their response headers won't include the appropriate CORS values.
          throw new Error(config.isBytescaleApi ? "Unable to resolve the Bytescale API: ".concat(e.message, " If the problem persists, and your network connection is OK, then please contact support@bytescale.com and provide: (a) time of failed request in UTC (b) screenshot of failed network response header + body (c) screenshot of failed network request header + body (d) browser and OS version.") : "Unable to resolve URL (".concat(url, "): ").concat(e.message));
        }), function (_result) {
          var _exit2 = false;
          if (_exit3) return _result;
          return response.status >= 200 && response.status < 300 ? response : runtime_invoke(function () {
            if (config.isBytescaleApi) {
              var errorText = undefined;
              var errorJson = undefined;
              return _continue(_catch(function () {
                return runtime_await(response.text(), function (_response$text) {
                  errorText = _response$text;
                  errorJson = JSON.parse(errorText);
                });
              }, runtime_empty), function () {
                if (typeof ((_a = errorJson === null || errorJson === void 0 ? void 0 : errorJson.error) === null || _a === void 0 ? void 0 : _a.code) === "string") {
                  throw new BytescaleApiError(errorJson);
                }
                if (config.debug === true) {
                  ConsoleUtils.debug("Error response header:");
                  response.headers.forEach(function (headerValue, headerKey) {
                    return ConsoleUtils.debug("".concat(headerKey, ": ").concat(headerValue));
                  });
                  ConsoleUtils.debug("Error response body:");
                  ConsoleUtils.debug(errorText !== null && errorText !== void 0 ? errorText : "<empty>");
                }
                // HTTP-level errors from intermediary services (e.g. AWS or the user's own infrastructure/proxies). On the browser,
                // this error is unlikely to be triggered since these errors will masqurade as CORS errors (see above) but in Node.js
                // this error will appear from any intermediary service failure. Also occurs when calling ProcessFile for an
                // asynchronous media job, where the transformation is initiated using the primary artifact: in this instance,
                // a 404 JSON response is returned containing the transformation job until it completes.
                throw new BytescaleGenericError(response, errorText, errorJson);
              });
            }
          }, function (_result2) {
            if (_exit2) return _result2;
            throw new Error("Failure status code (".concat(response.status, ") received for request: ").concat((_b = init.method) !== null && _b !== void 0 ? _b : "GET", " ").concat(url));
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return BaseAPI;
}();
var CancelledError = /*#__PURE__*/function (_Error) {
  _inherits(CancelledError, _Error);
  var _super = _createSuper(CancelledError);
  function CancelledError() {
    var _this5;
    runtime_classCallCheck(this, CancelledError);
    _this5 = _super.call(this, "Operation cancelled by caller.");
    _this5.name = "CancelledError";
    return _this5;
  }
  return runtime_createClass(CancelledError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Thrown when the Bytescale API cannot be reached or when an error is returned that cannot be parsed as a JSON error response.
 */
var BytescaleGenericError = /*#__PURE__*/function (_Error2) {
  _inherits(BytescaleGenericError, _Error2);
  var _super2 = _createSuper(BytescaleGenericError);
  function BytescaleGenericError(response, responseText, responseJson) {
    var _this6;
    runtime_classCallCheck(this, BytescaleGenericError);
    _this6 = _super2.call(this, "Unable to connect to the Bytescale API (".concat(response.status, "): please try again."));
    _this6.response = response;
    _this6.responseText = responseText;
    _this6.responseJson = responseJson;
    _this6.name = "BytescaleGenericError";
    return _this6;
  }
  return runtime_createClass(BytescaleGenericError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Thrown when the Bytescale API returns a JSON error response.
 */
var BytescaleApiError = /*#__PURE__*/function (_Error3) {
  _inherits(BytescaleApiError, _Error3);
  var _super3 = _createSuper(BytescaleApiError);
  function BytescaleApiError(response) {
    var _this7;
    runtime_classCallCheck(this, BytescaleApiError);
    _this7 = _super3.call(this, response.error.message);
    _this7.name = "BytescaleApiError";
    _this7.errorCode = response.error.code;
    _this7.details = response.error.details;
    return _this7;
  }
  return runtime_createClass(BytescaleApiError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
function moveElementToEnd(array, element) {
  return [].concat(_toConsumableArray(array.filter(function (x) {
    return x !== element;
  })), _toConsumableArray(array.filter(function (x) {
    return x === element;
  })));
}
function querystring(params) {
  // The 'artifact' param must be the last param for certain transformations, such as async HLS jobs. For example,
  // given an artifact '!f=hls-h264&artifact=/video.m3u8' that returns a master M3U8 playlist containing relative
  // links to child M3U8 playlists (e.g. 'child1.m3u8'), when the child URLs inside the master M3U8 file are resolved
  // by the browser, the 'child1.m3u8' path essentially replaces everything after the '/' on the master M3U8 URL.
  // Thus, if query params existed after the 'artifact' param, they would be wiped out, causing the child M3U8
  // playlist to suddenly reference a different transformation.
  var keysReordered = moveElementToEnd(Object.keys(params), "artifact");
  return keysReordered.map(function (key) {
    return querystringSingleKey(key, params[key]);
  }).filter(function (part) {
    return part.length > 0;
  }).join("&");
}
function querystringSingleKey(key, value) {
  if (value instanceof Object) {
    // Matches 'array' or 'object' (which we want).
    return querystring(value);
  }
  return encodeBytescaleQuerystringKVP(key, String(value));
}
/**
 * Handles artifacts specially as these must use "/" instead of "%2F" in order for relative paths within the artifact's
 * contents to work (assumes user has replaced "?" with "!"). For example, M3U8 artifacts that contain relative URLs to
 * other M3U8s and/or media segments will only work if the user replaces "?" with "!" in the URL _and_ the artifact
 * query param value has been written using "/" instead of "%2F", as this then means the URLs become relative to the
 * artifact, as opposed to the file path.
 */
function encodeBytescaleQuerystringKVP(key, value) {
  if (key === "a" || key === "artifact") {
    return "".concat(key, "=").concat(encodeURIComponent(value).replace(/%2F/g, "/"));
  }
  return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
}
var JSONApiResponse = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    runtime_classCallCheck(this, JSONApiResponse);
    this.raw = raw;
  }
  runtime_createClass(JSONApiResponse, [{
    key: "value",
    value: function value() {
      try {
        var _this9 = this;
        return runtime_await(_this9.raw.json());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return JSONApiResponse;
}();
var VoidApiResponse = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    runtime_classCallCheck(this, VoidApiResponse);
    this.raw = raw;
  }
  runtime_createClass(VoidApiResponse, [{
    key: "value",
    value: function value() {
      return runtime_await(undefined);
    }
  }]);
  return VoidApiResponse;
}();
var BinaryResult = /*#__PURE__*/function () {
  function BinaryResult(raw) {
    runtime_classCallCheck(this, BinaryResult);
    this.raw = raw;
  }
  runtime_createClass(BinaryResult, [{
    key: "stream",
    value: function stream() {
      if (this.raw.bodyUsed) {
        throw new Error("Response body has already been consumed.");
      }
      if (this.raw.body === null) {
        throw new Error("Response body does not exist.");
      }
      return this.raw.body;
    }
  }, {
    key: "text",
    value: function text() {
      try {
        var _this11 = this;
        return runtime_await(_this11.raw.text());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "blob",
    value: function blob() {
      try {
        var _this13 = this;
        return runtime_await(_this13.raw.blob());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "json",
    value: function json() {
      try {
        var _this15 = this;
        return runtime_await(_this15.raw.json());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return BinaryResult;
}();
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/FileApi.ts
function FileApi_typeof(obj) { "@babel/helpers - typeof"; return FileApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FileApi_typeof(obj); }
function FileApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function FileApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function FileApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, FileApi_toPropertyKey(descriptor.key), descriptor); } }
function FileApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) FileApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) FileApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function FileApi_toPropertyKey(arg) { var key = FileApi_toPrimitive(arg, "string"); return FileApi_typeof(key) === "symbol" ? key : String(key); }
function FileApi_toPrimitive(input, hint) { if (FileApi_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (FileApi_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function FileApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FileApi_setPrototypeOf(subClass, superClass); }
function FileApi_setPrototypeOf(o, p) { FileApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FileApi_setPrototypeOf(o, p); }
function FileApi_createSuper(Derived) { var hasNativeReflectConstruct = FileApi_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FileApi_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FileApi_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FileApi_possibleConstructorReturn(this, result); }; }
function FileApi_possibleConstructorReturn(self, call) { if (call && (FileApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FileApi_assertThisInitialized(self); }
function FileApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function FileApi_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function FileApi_getPrototypeOf(o) { FileApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FileApi_getPrototypeOf(o); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var FileApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  FileApi_inherits(FileApi, _runtime$BaseAPI);
  var _super = FileApi_createSuper(FileApi);
  function FileApi() {
    FileApi_classCallCheck(this, FileApi);
    return _super.apply(this, arguments);
  }
  FileApi_createClass(FileApi, [{
    key: "copyFile",
    value:
    /**
     * Copies a file synchronously.
     */
    function copyFile(params) {
      try {
        var _this2 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FileApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/files/copy".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this2.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.copyFileRequest
        }, undefined, [][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies multiple files asynchronously.
     */
  }, {
    key: "copyFileBatch",
    value: function copyFileBatch(params) {
      try {
        var _this4 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FileApi_await(_this4.request({
          path: "/v2/accounts/{accountId}/files/copy/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this4.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.copyFileBatchRequest
        }, undefined, [][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes a file synchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "deleteFile",
    value: function deleteFile(params) {
      try {
        var _this6 = this;
        var query = {};
        if (params.filePath !== undefined) {
          query["filePath"] = params.filePath;
        }
        var headers = {};
        return FileApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/files".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this6.encodeParam("accountId", params.accountId)),
          method: "DELETE",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return FileApi_await(new VoidApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes multiple files asynchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "deleteFileBatch",
    value: function deleteFileBatch(params) {
      try {
        var _this8 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FileApi_await(_this8.request({
          path: "/v2/accounts/{accountId}/files/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this8.encodeParam("accountId", params.accountId)),
          method: "DELETE",
          headers: headers,
          query: query,
          body: params.deleteFileBatchRequest
        }, undefined, [][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Downloads a file in its original/unprocessed state.
     */
  }, {
    key: "downloadFile",
    value: function downloadFile(params) {
      try {
        var _this10 = this;
        var query = {};
        if (params.cache !== undefined) {
          query["cache"] = params.cache;
        }
        if (params.cacheTtl !== undefined) {
          query["cache_ttl"] = params.cacheTtl;
        }
        if (params.version !== undefined) {
          query["version"] = params.version;
        }
        var headers = {};
        return FileApi_await(_this10.request({
          path: "/{accountId}/raw{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this10.encodeParam("accountId", params.accountId)).replace("{".concat("filePath", "}"),
          // @ts-ignore
          _this10.encodeParam("filePath", params.filePath)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, ["https://upcdn.io"][0]), function (response) {
          return new BinaryResult(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     */
  }, {
    key: "getFileDetails",
    value: function getFileDetails(params) {
      try {
        var _this12 = this;
        var query = {};
        if (params.filePath !== undefined) {
          query["filePath"] = params.filePath;
        }
        var headers = {};
        return FileApi_await(_this12.request({
          path: "/v2/accounts/{accountId}/files/details".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this12.encodeParam("accountId", params.accountId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Processes a file and returns the result.
     */
  }, {
    key: "processFile",
    value: function processFile(params) {
      try {
        var _this14 = this;
        var query = {};
        if (params.artifact !== undefined) {
          query["artifact"] = params.artifact;
        }
        if (params.cache !== undefined) {
          query["cache"] = params.cache;
        }
        if (params.cacheOnly !== undefined) {
          query["cache_only"] = params.cacheOnly;
        }
        if (params.cachePerm !== undefined) {
          query["cache_perm"] = params.cachePerm;
        }
        if (params.cacheTtl !== undefined) {
          query["cache_ttl"] = params.cacheTtl;
        }
        if (params.transformationParams !== undefined) {
          query["transformationParams"] = params.transformationParams;
        }
        if (params.version !== undefined) {
          query["version"] = params.version;
        }
        var headers = {};
        return FileApi_await(_this14.request({
          path: "/{accountId}/{transformation}{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this14.encodeParam("accountId", params.accountId)).replace("{".concat("filePath", "}"),
          // @ts-ignore
          _this14.encodeParam("filePath", params.filePath)).replace("{".concat("transformation", "}"),
          // @ts-ignore
          _this14.encodeParam("transformation", params.transformation)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, ["https://upcdn.io"][0]), function (response) {
          return new BinaryResult(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Processes a file and saves the result.
     */
  }, {
    key: "processFileAndSave",
    value: function processFileAndSave(params) {
      try {
        var _this16 = this;
        var query = {};
        if (params.transformationParams !== undefined) {
          query["transformationParams"] = params.transformationParams;
        }
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FileApi_await(_this16.request({
          path: "/{accountId}/save/{transformation}{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this16.encodeParam("accountId", params.accountId)).replace("{".concat("filePath", "}"),
          // @ts-ignore
          _this16.encodeParam("filePath", params.filePath)).replace("{".concat("transformation", "}"),
          // @ts-ignore
          _this16.encodeParam("transformation", params.transformation)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.processFileAndSaveRequest
        }, undefined, ["https://upcdn.io"][0]), function (response) {
          return FileApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return FileApi;
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/FolderApi.ts
function FolderApi_typeof(obj) { "@babel/helpers - typeof"; return FolderApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FolderApi_typeof(obj); }
function FolderApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function FolderApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function FolderApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, FolderApi_toPropertyKey(descriptor.key), descriptor); } }
function FolderApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) FolderApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) FolderApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function FolderApi_toPropertyKey(arg) { var key = FolderApi_toPrimitive(arg, "string"); return FolderApi_typeof(key) === "symbol" ? key : String(key); }
function FolderApi_toPrimitive(input, hint) { if (FolderApi_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (FolderApi_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function FolderApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FolderApi_setPrototypeOf(subClass, superClass); }
function FolderApi_setPrototypeOf(o, p) { FolderApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FolderApi_setPrototypeOf(o, p); }
function FolderApi_createSuper(Derived) { var hasNativeReflectConstruct = FolderApi_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FolderApi_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FolderApi_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FolderApi_possibleConstructorReturn(this, result); }; }
function FolderApi_possibleConstructorReturn(self, call) { if (call && (FolderApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FolderApi_assertThisInitialized(self); }
function FolderApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function FolderApi_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function FolderApi_getPrototypeOf(o) { FolderApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FolderApi_getPrototypeOf(o); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var FolderApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  FolderApi_inherits(FolderApi, _runtime$BaseAPI);
  var _super = FolderApi_createSuper(FolderApi);
  function FolderApi() {
    FolderApi_classCallCheck(this, FolderApi);
    return _super.apply(this, arguments);
  }
  FolderApi_createClass(FolderApi, [{
    key: "copyFolder",
    value:
    /**
     * Copies a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     */
    function copyFolder(params) {
      try {
        var _this2 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/folders/copy".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this2.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.copyFolderRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     */
  }, {
    key: "copyFolderBatch",
    value: function copyFolderBatch(params) {
      try {
        var _this4 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this4.request({
          path: "/v2/accounts/{accountId}/folders/copy/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this4.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.copyFolderBatchRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won\'t be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "deleteFolder",
    value: function deleteFolder(params) {
      try {
        var _this6 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this6.encodeParam("accountId", params.accountId)),
          method: "DELETE",
          headers: headers,
          query: query,
          body: params.deleteFolderRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won\'t be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "deleteFolderBatch",
    value: function deleteFolderBatch(params) {
      try {
        var _this8 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this8.request({
          path: "/v2/accounts/{accountId}/folders/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this8.encodeParam("accountId", params.accountId)),
          method: "DELETE",
          headers: headers,
          query: query,
          body: params.deleteFolderBatchRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "getFolderDetails",
    value: function getFolderDetails(params) {
      try {
        var _this10 = this;
        var query = {};
        if (params.folderPath !== undefined) {
          query["folderPath"] = params.folderPath;
        }
        var headers = {};
        return FolderApi_await(_this10.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this10.encodeParam("accountId", params.accountId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the folder\'s contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the next request.  Pagination is complete when the response includes `isPaginationComplete=true`.
     */
  }, {
    key: "listFolder",
    value: function listFolder(params) {
      try {
        var _this12 = this;
        var query = {};
        if (params.cursor !== undefined) {
          query["cursor"] = params.cursor;
        }
        if (params.dryRun !== undefined) {
          query["dryRun"] = params.dryRun;
        }
        if (params.folderPath !== undefined) {
          query["folderPath"] = params.folderPath;
        }
        if (params.includeFiles !== undefined) {
          query["includeFiles"] = params.includeFiles;
        }
        if (params.includeOverriddenStorage !== undefined) {
          query["includeOverriddenStorage"] = params.includeOverriddenStorage;
        }
        if (params.includePhysicalFolders !== undefined) {
          query["includePhysicalFolders"] = params.includePhysicalFolders;
        }
        if (params.includeVirtualFolders !== undefined) {
          query["includeVirtualFolders"] = params.includeVirtualFolders;
        }
        if (params.limit !== undefined) {
          query["limit"] = params.limit;
        }
        if (params.recursive !== undefined) {
          query["recursive"] = params.recursive;
        }
        var headers = {};
        return FolderApi_await(_this12.request({
          path: "/v2/accounts/{accountId}/folders/list".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this12.encodeParam("accountId", params.accountId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Creates or updates the folder specified by the `folderPath`.  If the folder\'s ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don\'t need to create folders before uploading files to them.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     */
  }, {
    key: "putFolder",
    value: function putFolder(params) {
      try {
        var _this14 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return FolderApi_await(_this14.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this14.encodeParam("accountId", params.accountId)),
          method: "PUT",
          headers: headers,
          query: query,
          body: params.putFolderRequest
        }, undefined, [][0]), function (response) {
          return FolderApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return FolderApi;
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/JobApi.ts
function JobApi_typeof(obj) { "@babel/helpers - typeof"; return JobApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, JobApi_typeof(obj); }
function JobApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function JobApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function JobApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, JobApi_toPropertyKey(descriptor.key), descriptor); } }
function JobApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) JobApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) JobApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function JobApi_toPropertyKey(arg) { var key = JobApi_toPrimitive(arg, "string"); return JobApi_typeof(key) === "symbol" ? key : String(key); }
function JobApi_toPrimitive(input, hint) { if (JobApi_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (JobApi_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function JobApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) JobApi_setPrototypeOf(subClass, superClass); }
function JobApi_setPrototypeOf(o, p) { JobApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return JobApi_setPrototypeOf(o, p); }
function JobApi_createSuper(Derived) { var hasNativeReflectConstruct = JobApi_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = JobApi_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = JobApi_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return JobApi_possibleConstructorReturn(this, result); }; }
function JobApi_possibleConstructorReturn(self, call) { if (call && (JobApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return JobApi_assertThisInitialized(self); }
function JobApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function JobApi_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function JobApi_getPrototypeOf(o) { JobApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return JobApi_getPrototypeOf(o); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var JobApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  JobApi_inherits(JobApi, _runtime$BaseAPI);
  var _super = JobApi_createSuper(JobApi);
  function JobApi() {
    JobApi_classCallCheck(this, JobApi);
    return _super.apply(this, arguments);
  }
  JobApi_createClass(JobApi, [{
    key: "cancelJob",
    value:
    /**
     * Cancels an in-progress background job.  Requires a `secret_*` API key.
     */
    function cancelJob(params) {
      try {
        var _this2 = this;
        var query = {};
        var headers = {};
        return JobApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/jobs/{jobType}/{jobId}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this2.encodeParam("accountId", params.accountId)).replace("{".concat("jobId", "}"),
          // @ts-ignore
          _this2.encodeParam("jobId", params.jobId)).replace("{".concat("jobType", "}"),
          // @ts-ignore
          _this2.encodeParam("jobType", params.jobType)),
          method: "DELETE",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return JobApi_await(new VoidApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets information on a background job.  Requires a `secret_*` API key.
     */
  }, {
    key: "getJob",
    value: function getJob(params) {
      try {
        var _this4 = this;
        var query = {};
        var headers = {};
        return JobApi_await(_this4.request({
          path: "/v2/accounts/{accountId}/jobs/{jobType}/{jobId}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this4.encodeParam("accountId", params.accountId)).replace("{".concat("jobId", "}"),
          // @ts-ignore
          _this4.encodeParam("jobId", params.jobId)).replace("{".concat("jobType", "}"),
          // @ts-ignore
          _this4.encodeParam("jobType", params.jobType)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return JobApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the most recently issued background jobs.  Requires a `secret_*` API key.
     */
  }, {
    key: "listRecentJobs",
    value: function listRecentJobs(params) {
      try {
        var _this6 = this;
        var query = {};
        if (params.jobType) {
          query["jobType"] = params.jobType;
        }
        var headers = {};
        return JobApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/jobs".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this6.encodeParam("accountId", params.accountId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return JobApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return JobApi;
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/UploadApi.ts
function UploadApi_typeof(obj) { "@babel/helpers - typeof"; return UploadApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, UploadApi_typeof(obj); }
function UploadApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadApi_toPropertyKey(descriptor.key), descriptor); } }
function UploadApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadApi_toPropertyKey(arg) { var key = UploadApi_toPrimitive(arg, "string"); return UploadApi_typeof(key) === "symbol" ? key : String(key); }
function UploadApi_toPrimitive(input, hint) { if (UploadApi_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (UploadApi_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function UploadApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) UploadApi_setPrototypeOf(subClass, superClass); }
function UploadApi_setPrototypeOf(o, p) { UploadApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return UploadApi_setPrototypeOf(o, p); }
function UploadApi_createSuper(Derived) { var hasNativeReflectConstruct = UploadApi_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = UploadApi_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = UploadApi_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return UploadApi_possibleConstructorReturn(this, result); }; }
function UploadApi_possibleConstructorReturn(self, call) { if (call && (UploadApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return UploadApi_assertThisInitialized(self); }
function UploadApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function UploadApi_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function UploadApi_getPrototypeOf(o) { UploadApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return UploadApi_getPrototypeOf(o); }
/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

var UploadApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  UploadApi_inherits(UploadApi, _runtime$BaseAPI);
  var _super = UploadApi_createSuper(UploadApi);
  function UploadApi() {
    UploadApi_classCallCheck(this, UploadApi);
    return _super.apply(this, arguments);
  }
  UploadApi_createClass(UploadApi, [{
    key: "beginMultipartUpload",
    value:
    /**
     * Begins a new multipart file upload process.
     */
    function beginMultipartUpload(params) {
      try {
        var _this2 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return UploadApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/uploads".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this2.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.beginMultipartUploadRequest
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Marks an upload part as uploaded.  You must call this endpoint after you have successfully issued a `PUT` request to the `uploadUrl` on the corresponding UploadPart.
     */
  }, {
    key: "completeUploadPart",
    value: function completeUploadPart(params) {
      try {
        var _this4 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return UploadApi_await(_this4.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts/{uploadPartIndex}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this4.encodeParam("accountId", params.accountId)).replace("{".concat("uploadId", "}"),
          // @ts-ignore
          _this4.encodeParam("uploadId", params.uploadId)).replace("{".concat("uploadPartIndex", "}"),
          // @ts-ignore
          _this4.encodeParam("uploadPartIndex", params.uploadPartIndex)),
          method: "PUT",
          headers: headers,
          query: query,
          body: params.completeUploadPartRequest
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new VoidApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets a remaining upload part for a multipart file upload.
     */
  }, {
    key: "getUploadPart",
    value: function getUploadPart(params) {
      try {
        var _this6 = this;
        var query = {};
        var headers = {};
        return UploadApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts/{uploadPartIndex}".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this6.encodeParam("accountId", params.accountId)).replace("{".concat("uploadId", "}"),
          // @ts-ignore
          _this6.encodeParam("uploadId", params.uploadId)).replace("{".concat("uploadPartIndex", "}"),
          // @ts-ignore
          _this6.encodeParam("uploadPartIndex", params.uploadPartIndex)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the remaining upload parts for a multipart file upload.  An empty array is returned when the upload is complete.
     */
  }, {
    key: "listUploadParts",
    value: function listUploadParts(params) {
      try {
        var _this8 = this;
        var query = {};
        var headers = {};
        return UploadApi_await(_this8.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this8.encodeParam("accountId", params.accountId)).replace("{".concat("uploadId", "}"),
          // @ts-ignore
          _this8.encodeParam("uploadId", params.uploadId)),
          method: "GET",
          headers: headers,
          query: query
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Upload from a URL with a single HTTP request:
     */
  }, {
    key: "uploadFromUrl",
    value: function uploadFromUrl(params) {
      try {
        var _this10 = this;
        var query = {};
        var headers = {};
        headers["Content-Type"] = "application/json";
        return UploadApi_await(_this10.request({
          path: "/v2/accounts/{accountId}/uploads/url".replace("{".concat("accountId", "}"),
          // @ts-ignore
          _this10.encodeParam("accountId", params.accountId)),
          method: "POST",
          headers: headers,
          query: query,
          body: params.uploadFromUrlRequest
        }, undefined, [][0]), function (response) {
          return UploadApi_await(new JSONApiResponse(response).value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return UploadApi;
}(BaseAPI);
;// CONCATENATED MODULE: ./src/public/shared/generated/apis/index.ts
/* tslint:disable */
/* eslint-disable */




;// CONCATENATED MODULE: ./src/public/shared/generated/index.ts
/* tslint:disable */
/* eslint-disable */



;// CONCATENATED MODULE: ./src/public/shared/CommonTypes.ts
/**
 * Workaround for tsc aliases, where we cannot export implementation-less libs in our dists.
 */
var CommonTypesNoOp = false;
;// CONCATENATED MODULE: ./src/private/TypeUtils.ts
function assertUnreachable(x) {
  throw new Error("Didn't expect to get here: ".concat(JSON.stringify(x)));
}
function isDefinedEntry(object) {
  return object[1] !== undefined && object[1] !== null;
}
;// CONCATENATED MODULE: ./src/public/shared/UrlBuilder.ts
function UrlBuilder_typeof(obj) { "@babel/helpers - typeof"; return UrlBuilder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, UrlBuilder_typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || UrlBuilder_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function UrlBuilder_toConsumableArray(arr) { return UrlBuilder_arrayWithoutHoles(arr) || UrlBuilder_iterableToArray(arr) || UrlBuilder_unsupportedIterableToArray(arr) || UrlBuilder_nonIterableSpread(); }
function UrlBuilder_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function UrlBuilder_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return UrlBuilder_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return UrlBuilder_arrayLikeToArray(o, minLen); }
function UrlBuilder_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function UrlBuilder_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return UrlBuilder_arrayLikeToArray(arr); }
function UrlBuilder_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function UrlBuilder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UrlBuilder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UrlBuilder_toPropertyKey(descriptor.key), descriptor); } }
function UrlBuilder_createClass(Constructor, protoProps, staticProps) { if (protoProps) UrlBuilder_defineProperties(Constructor.prototype, protoProps); if (staticProps) UrlBuilder_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UrlBuilder_toPropertyKey(arg) { var key = UrlBuilder_toPrimitive(arg, "string"); return UrlBuilder_typeof(key) === "symbol" ? key : String(key); }
function UrlBuilder_toPrimitive(input, hint) { if (UrlBuilder_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (UrlBuilder_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


var UrlBuilder = /*#__PURE__*/function () {
  function UrlBuilder() {
    UrlBuilder_classCallCheck(this, UrlBuilder);
  }
  UrlBuilder_createClass(UrlBuilder, null, [{
    key: "url",
    value:
    /**
     * Builds a URL to either a raw file or a transformed file.
     *
     * Example 1) Getting a publicly-accessible raw file URL:
     *
     *   new UrlBuilder().url({ accountId: "1234abc", filePath: "/example.jpg" })
     *
     * Example 2) Getting a publicly-accessible image URL, resized to 500x500:
     *
     *   new UrlBuilder().url({ accountId: "1234abc", filePath: "/example.jpg", options: { transformation: { type: "image", params: { w: 500, h: 500, fit: "crop" } } } })
     *
     * Example 3) Getting a privately-accessible image URL, resized to 500x500 (requires 'AuthManager.beginAuthSession' to be called before accessing the URL):
     *
     *   new UrlBuilder().url({ accountId: "1234abc", filePath: "/example.jpg", options: { transformation: { type: "image", params: { w: 500, h: 500, fit: "crop" } }, auth: true } })
     *
     * Example 4) Getting a publicly-accessible image URL, resized using a transformation preset called "thumbnail" that was created manually in the Bytescale Dashboard:
     *
     *   new UrlBuilder().url({ accountId: "1234abc", filePath: "/example.jpg", options: { transformation: { type: "preset", preset: "thumbnail" } } })
     */
    function url(params) {
      var _a;
      return ((_a = params.options) === null || _a === void 0 ? void 0 : _a.transformation) === undefined ? this.raw(params) : this.transformation(params, params.options);
    }
  }, {
    key: "raw",
    value: function raw(params) {
      var _a;
      var baseUrl = this.getBaseUrl(params, "raw");
      var commonParams = this.getCommonQueryParams((_a = params.options) !== null && _a !== void 0 ? _a : {});
      return this.addQueryParams(baseUrl, commonParams);
    }
  }, {
    key: "transformation",
    value: function transformation(params, trans) {
      var _a;
      var baseUrl = this.getBaseUrl(params, trans.transformation === "preset" ? trans.transformationPreset : trans.transformation);
      var transParams = trans.transformation === "preset" ? [] : this.getTransformationParams(trans);
      var commonParams = this.getCommonQueryParams((_a = params.options) !== null && _a !== void 0 ? _a : {});
      var transCommonParams = this.getCommonTransformationQueryParams(trans);
      // This format puts "artifact" at the end, which isn't required, but is convention.
      return this.addQueryParams(baseUrl, [].concat(UrlBuilder_toConsumableArray(transParams), UrlBuilder_toConsumableArray(commonParams), UrlBuilder_toConsumableArray(transCommonParams)));
    }
  }, {
    key: "getBaseUrl",
    value: function getBaseUrl(params, prefix) {
      var _a, _b;
      var cdnUrl = (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.cdnUrl) !== null && _b !== void 0 ? _b : BytescaleApiClientConfigUtils.defaultCdnUrl;
      var filePathEncoded = encodeURIComponent(params.filePath).replace(/%2F/g, "/");
      return "".concat(cdnUrl, "/").concat(params.accountId, "/").concat(prefix).concat(filePathEncoded);
    }
  }, {
    key: "getCommonTransformationQueryParams",
    value: function getCommonTransformationQueryParams(trans) {
      return this.makeQueryParams({
        cacheOnly: null,
        cachePermanently: null,
        // Keep this as the last param: this is required for certain transformations, such as async HLS jobs. For example,
        // given an artifact '!f=hls-h264&artifact=/video.m3u8' that returns a master M3U8 playlist containing relative
        // links to child M3U8 playlists (e.g. 'child1.m3u8'), when the child URLs inside the master M3U8 file are resolved
        // by the browser, the 'child1.m3u8' path essentially replaces everything after the '/' on the master M3U8 URL.
        // Thus, if query params existed after the 'artifact' param, they would be wiped out, causing the child M3U8
        // playlist to suddenly reference a different transformation.
        artifact: null
      }, {
        cacheOnly: "cache_only",
        cachePermanently: "cache_perm"
      })(trans);
    }
  }, {
    key: "getCommonQueryParams",
    value: function getCommonQueryParams(params) {
      return this.makeQueryParams({
        cache: null,
        cacheTtl: null,
        version: null,
        forceDownloadPrompt: null
      }, {
        cacheTtl: "cache_ttl",
        forceDownloadPrompt: "download"
      })(params);
    }
    /**
     * Masks the querystring params per the 'keys' array.
     *
     * Order sensitive: querystring params will appear per the order of the 'keys' array.
     */
  }, {
    key: "makeQueryParams",
    value: function makeQueryParams(keyPrototype, keyOverrides) {
      return function (data) {
        var result = [];
        var keys = Object.keys(keyPrototype);
        keys.forEach(function (key) {
          var _a;
          var value = data[key];
          if (value !== undefined) {
            result.push([(_a = keyOverrides[key]) !== null && _a !== void 0 ? _a : key, value.toString()]);
          }
        });
        return result;
      };
    }
  }, {
    key: "getTransformationParams",
    value: function getTransformationParams(trans) {
      var params = trans.transformationParams;
      if (params === undefined) {
        return [];
      }
      var serializeObj = function serializeObj(obj) {
        return Object.entries(obj).filter(isDefinedEntry).map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];
          return [key, value.toString()];
        });
      };
      return Array.isArray(params) ? params.flatMap(serializeObj) : serializeObj(params);
    }
  }, {
    key: "addQueryParams",
    value: function addQueryParams(baseUrl, params) {
      if (params.length === 0) {
        return baseUrl;
      }
      return "".concat(baseUrl, "?").concat(params.map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];
        return encodeBytescaleQuerystringKVP(key, value);
      }).join("&"));
    }
  }]);
  return UrlBuilder;
}();
;// CONCATENATED MODULE: ./src/public/shared/UrlBuilderTypes.ts
/**
 * Workaround for tsc aliases, where we cannot export implementation-less libs in our dists.
 */
var UrlBuilderTypesNoOp = false;
;// CONCATENATED MODULE: ./src/public/shared/index.ts




;// CONCATENATED MODULE: ./src/private/UploadManagerBase.ts
function UploadManagerBase_typeof(obj) { "@babel/helpers - typeof"; return UploadManagerBase_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, UploadManagerBase_typeof(obj); }
function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function _invokeIgnored(body) {
  var result = body();
  if (result && result.then) {
    return result.then(UploadManagerBase_empty);
  }
}
function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }
        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }
    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }
    pact.s = state;
    pact.v = value;
    var observer = pact.o;
    if (observer) {
      observer(pact);
    }
  }
}
var _Pact = /*#__PURE__*/function () {
  function _Pact() {}
  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;
    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;
      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }
        return result;
      } else {
        return this;
      }
    }
    this.o = function (_this) {
      try {
        var value = _this.v;
        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };
    return result;
  };
  return _Pact;
}();
function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}
function _for(test, update, body) {
  var stage;
  for (;;) {
    var shouldContinue = test();
    if (_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }
    if (!shouldContinue) {
      return result;
    }
    if (shouldContinue.then) {
      stage = 0;
      break;
    }
    var result = body();
    if (result && result.then) {
      if (_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }
    if (update) {
      var updateValue = update();
      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }
  var pact = new _Pact();
  var reject = _settle.bind(null, pact, 2);
  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;
  function _resumeAfterBody(value) {
    result = value;
    do {
      if (update) {
        updateValue = update();
        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }
      shouldContinue = test();
      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
        _settle(pact, 1, result);
        return;
      }
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }
      result = body();
      if (_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);
    result.then(_resumeAfterBody).then(void 0, reject);
  }
  function _resumeAfterTest(shouldContinue) {
    if (shouldContinue) {
      result = body();
      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
}
function _continueIgnored(value) {
  if (value && value.then) {
    return value.then(UploadManagerBase_empty);
  }
}
function UploadManagerBase_toConsumableArray(arr) { return UploadManagerBase_arrayWithoutHoles(arr) || UploadManagerBase_iterableToArray(arr) || UploadManagerBase_unsupportedIterableToArray(arr) || UploadManagerBase_nonIterableSpread(); }
function UploadManagerBase_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function UploadManagerBase_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return UploadManagerBase_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return UploadManagerBase_arrayLikeToArray(o, minLen); }
function UploadManagerBase_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function UploadManagerBase_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return UploadManagerBase_arrayLikeToArray(arr); }
function UploadManagerBase_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function UploadManagerBase_empty() {}
function UploadManagerBase_awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(UploadManagerBase_empty) : Promise.resolve();
  }
}
function UploadManagerBase_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadManagerBase_rethrow(thrown, value) {
  if (thrown) throw value;
  return value;
}
function UploadManagerBase_finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }
  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }
  return finalizer(false, result);
}
function UploadManagerBase_continue(value, then) {
  return value && value.then ? value.then(then) : then(value);
}
function UploadManagerBase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadManagerBase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadManagerBase_toPropertyKey(descriptor.key), descriptor); } }
function UploadManagerBase_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadManagerBase_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadManagerBase_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadManagerBase_toPropertyKey(arg) { var key = UploadManagerBase_toPrimitive(arg, "string"); return UploadManagerBase_typeof(key) === "symbol" ? key : String(key); }
function UploadManagerBase_toPrimitive(input, hint) { if (UploadManagerBase_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (UploadManagerBase_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

/**
 * Methods common to UploadManagerNode and UploadManagerBrowser.
 */
var UploadManagerBase = /*#__PURE__*/function () {
  function UploadManagerBase(config) {
    UploadManagerBase_classCallCheck(this, UploadManagerBase);
    this.config = config;
    this.stringMimeType = "text/plain";
    this.defaultMaxConcurrentUploadParts = 4;
    this.intervalMs = 500;
    this.uploadApi = new UploadApi(config);
    this.accountId = BytescaleApiClientConfigUtils.getAccountId(config);
  }
  UploadManagerBase_createClass(UploadManagerBase, [{
    key: "upload",
    value: function upload(request) {
      try {
        var _this2 = this;
        _this2.assertNotCancelled(request);
        var source = _this2.processUploadSource(request.data);
        var preUploadInfo = _this2.getPreUploadInfo(request, source);
        var bytesTotal = preUploadInfo.size;
        var makeOnProgressForPart = _this2.makeOnProgressForPartFactory(request, bytesTotal);
        var init = _this2.preUpload(source);
        // Raise initial progress event SYNCHRONOUSLY.
        if (request.onProgress !== undefined) {
          request.onProgress(_this2.makeProgressEvent(0, bytesTotal));
        }
        return UploadManagerBase_await(_this2.beginUpload(request, preUploadInfo), function (uploadInfo) {
          var partCount = uploadInfo.uploadParts.count;
          var parts = UploadManagerBase_toConsumableArray(Array(partCount).keys());
          var _this2$makeCancellati = _this2.makeCancellationMethods(),
            cancel = _this2$makeCancellati.cancel,
            addCancellationHandler = _this2$makeCancellati.addCancellationHandler;
          var intervalHandle = setInterval(_this2.onIntervalTick(request, cancel), _this2.intervalMs);
          return UploadManagerBase_continue(UploadManagerBase_finallyRethrows(function () {
            return UploadManagerBase_await(_this2.mapAsync(parts, preUploadInfo.maxConcurrentUploadParts, _async(function (part) {
              return _this2.uploadPart(request, source, part, uploadInfo, makeOnProgressForPart(), addCancellationHandler);
            })), function () {
              return UploadManagerBase_awaitIgnored(_this2.postUpload(init));
            });
          }, function (_wasThrown, _result) {
            clearInterval(intervalHandle);
            return UploadManagerBase_rethrow(_wasThrown, _result);
          }), function () {
            return uploadInfo.file;
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getBlobInfo",
    value: function getBlobInfo(_ref) {
      var _ref$value = _ref.value,
        name = _ref$value.name,
        size = _ref$value.size,
        type = _ref$value.type;
      return {
        // Some browsers/OSs return 'type: ""' for files with unknown MIME types, like HEICs, which causes a validation
        // error from the Bytescale API as "" is not a valid MIME type, so we coalesce to undefined here.
        mime: type === "" ? undefined : type,
        size: size,
        originalFileName: name,
        maxConcurrentUploadParts: undefined
      };
    }
  }, {
    key: "onIntervalTick",
    value: function onIntervalTick(request, cancel) {
      var _this3 = this;
      return function () {
        if (_this3.isCancelled(request)) {
          cancel();
        }
      };
    }
  }, {
    key: "makeCancellationMethods",
    value: function makeCancellationMethods() {
      var cancellationHandlers = [];
      var addCancellationHandler = function addCancellationHandler(ca) {
        cancellationHandlers.push(ca);
      };
      var cancel = function cancel() {
        return cancellationHandlers.forEach(function (x) {
          return x();
        });
      };
      return {
        cancel: cancel,
        addCancellationHandler: addCancellationHandler
      };
    }
    /**
     * Returns a callback, which when called, returns a callback that can be used by ONE specific part to report its progress.
     */
  }, {
    key: "makeOnProgressForPartFactory",
    value: function makeOnProgressForPartFactory(request, bytesTotal) {
      var _this4 = this;
      var onProgress = request.onProgress;
      if (onProgress === undefined) {
        return function () {
          return function () {};
        };
      }
      var bytesSent = 0;
      return function () {
        var bytesSentForPart = 0;
        return function (bytesSentTotalForPart) {
          var delta = bytesSentTotalForPart - bytesSentForPart;
          bytesSentForPart += delta;
          bytesSent += delta;
          onProgress(_this4.makeProgressEvent(bytesSent, bytesTotal));
        };
      };
    }
  }, {
    key: "makeProgressEvent",
    value: function makeProgressEvent(bytesSent, bytesTotal) {
      return {
        bytesTotal: bytesTotal,
        bytesSent: bytesSent,
        progress: Math.round(bytesSent / bytesTotal * 100)
      };
    }
  }, {
    key: "assertNotCancelled",
    value: function assertNotCancelled(request) {
      if (this.isCancelled(request)) {
        throw new CancelledError();
      }
    }
  }, {
    key: "isCancelled",
    value: function isCancelled(request) {
      var _a;
      return ((_a = request.cancellationToken) === null || _a === void 0 ? void 0 : _a.isCancelled) === true;
    }
  }, {
    key: "beginUpload",
    value: function beginUpload(request, _ref2) {
      var size = _ref2.size,
        mime = _ref2.mime,
        originalFileName = _ref2.originalFileName;
      try {
        var _this6 = this;
        return UploadManagerBase_await(_this6.uploadApi.beginMultipartUpload({
          accountId: _this6.accountId,
          beginMultipartUploadRequest: {
            metadata: request.metadata,
            mime: mime,
            originalFileName: originalFileName,
            path: request.path,
            protocol: "1.1",
            size: size,
            tags: request.tags
          }
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "uploadPart",
    value: function uploadPart(request, source, partIndex, uploadInfo, onProgress, addCancellationHandler) {
      try {
        var _this8 = this;
        _this8.assertNotCancelled(request);
        return UploadManagerBase_await(_this8.getUploadPart(partIndex, uploadInfo), function (part) {
          _this8.assertNotCancelled(request);
          return UploadManagerBase_await(_this8.putUploadPart(part, source, onProgress, addCancellationHandler), function (etag) {
            _this8.assertNotCancelled(request);
            return UploadManagerBase_awaitIgnored(_this8.uploadApi.completeUploadPart({
              accountId: _this8.accountId,
              uploadId: uploadInfo.uploadId,
              uploadPartIndex: partIndex,
              completeUploadPartRequest: {
                etag: etag
              }
            }));
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Returns etag for the part.
     */
  }, {
    key: "putUploadPart",
    value: function putUploadPart(part, source, onProgress, addCancellationHandler) {
      try {
        var _this10 = this;
        var contentLength = part.range.inclusiveEnd + 1 - part.range.inclusiveStart;
        return UploadManagerBase_await(_this10.doPutUploadPart(part, contentLength, source, onProgress, addCancellationHandler), function (_ref3) {
          var status = _ref3.status,
            etag = _ref3.etag;
          if (Math.floor(status / 100) !== 2) {
            throw new Error("Failed to upload part (".concat(status, ")."));
          }
          if (etag === undefined) {
            throw new Error("No 'etag' response header found in upload part response.");
          }
          // Always send 100% for part, as some UploadManager implementations either don't report progress, or may not report the last chunk uploaded.
          onProgress(contentLength);
          return etag;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getUploadPart",
    value: function getUploadPart(partIndex, uploadInfo) {
      try {
        var _this12 = this;
        if (partIndex === 0) {
          return uploadInfo.uploadParts.first;
        }
        return UploadManagerBase_await(_this12.uploadApi.getUploadPart({
          uploadId: uploadInfo.uploadId,
          accountId: _this12.accountId,
          uploadPartIndex: partIndex
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getPreUploadInfo",
    value: function getPreUploadInfo(request, source) {
      var _a, _b, _c;
      var partial = this.getPreUploadInfoPartial(request, source);
      return {
        maxConcurrentUploadParts: (_a = partial.maxConcurrentUploadParts) !== null && _a !== void 0 ? _a : this.defaultMaxConcurrentUploadParts,
        originalFileName: (_b = request.originalFileName) !== null && _b !== void 0 ? _b : partial.originalFileName,
        mime: (_c = request.mime) !== null && _c !== void 0 ? _c : partial.mime,
        size: partial.size
      };
    }
  }, {
    key: "mapAsync",
    value: function mapAsync(items, concurrency, callback) {
      try {
        var workQueue = UploadManagerBase_toConsumableArray(items);
        return UploadManagerBase_awaitIgnored(Promise.all(UploadManagerBase_toConsumableArray(Array(concurrency).keys()).map(_async(function () {
          return _continueIgnored(_for(function () {
            return workQueue.length > 0;
          }, void 0, function () {
            var work = workQueue.shift(); // IMPORTANT: use 'shift' instead of 'pop' to ensure 'items' are processed in order when 'concurrency = 1'.
            return _invokeIgnored(function () {
              if (work !== undefined) {
                return UploadManagerBase_awaitIgnored(callback(work));
              }
            });
          }));
        }))));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return UploadManagerBase;
}();
;// CONCATENATED MODULE: ./src/private/UploadManagerBrowserWorkerBase.ts
function UploadManagerBrowserWorkerBase_typeof(obj) { "@babel/helpers - typeof"; return UploadManagerBrowserWorkerBase_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, UploadManagerBrowserWorkerBase_typeof(obj); }
function UploadManagerBrowserWorkerBase_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadManagerBrowserWorkerBase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadManagerBrowserWorkerBase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadManagerBrowserWorkerBase_toPropertyKey(descriptor.key), descriptor); } }
function UploadManagerBrowserWorkerBase_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadManagerBrowserWorkerBase_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadManagerBrowserWorkerBase_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadManagerBrowserWorkerBase_toPropertyKey(arg) { var key = UploadManagerBrowserWorkerBase_toPrimitive(arg, "string"); return UploadManagerBrowserWorkerBase_typeof(key) === "symbol" ? key : String(key); }
function UploadManagerBrowserWorkerBase_toPrimitive(input, hint) { if (UploadManagerBrowserWorkerBase_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (UploadManagerBrowserWorkerBase_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function UploadManagerBrowserWorkerBase_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) UploadManagerBrowserWorkerBase_setPrototypeOf(subClass, superClass); }
function UploadManagerBrowserWorkerBase_setPrototypeOf(o, p) { UploadManagerBrowserWorkerBase_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return UploadManagerBrowserWorkerBase_setPrototypeOf(o, p); }
function UploadManagerBrowserWorkerBase_createSuper(Derived) { var hasNativeReflectConstruct = UploadManagerBrowserWorkerBase_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = UploadManagerBrowserWorkerBase_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = UploadManagerBrowserWorkerBase_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return UploadManagerBrowserWorkerBase_possibleConstructorReturn(this, result); }; }
function UploadManagerBrowserWorkerBase_possibleConstructorReturn(self, call) { if (call && (UploadManagerBrowserWorkerBase_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return UploadManagerBrowserWorkerBase_assertThisInitialized(self); }
function UploadManagerBrowserWorkerBase_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function UploadManagerBrowserWorkerBase_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function UploadManagerBrowserWorkerBase_getPrototypeOf(o) { UploadManagerBrowserWorkerBase_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return UploadManagerBrowserWorkerBase_getPrototypeOf(o); }


/**
 * The "browser" and "worker" runtimes support the same input types, but the former uses XHR and the latter uses Fetch.
 */
var UploadManagerBrowserWorkerBase = /*#__PURE__*/function (_UploadManagerBase) {
  UploadManagerBrowserWorkerBase_inherits(UploadManagerBrowserWorkerBase, _UploadManagerBase);
  var _super = UploadManagerBrowserWorkerBase_createSuper(UploadManagerBrowserWorkerBase);
  function UploadManagerBrowserWorkerBase() {
    UploadManagerBrowserWorkerBase_classCallCheck(this, UploadManagerBrowserWorkerBase);
    return _super.apply(this, arguments);
  }
  UploadManagerBrowserWorkerBase_createClass(UploadManagerBrowserWorkerBase, [{
    key: "processUploadSource",
    value: function processUploadSource(data) {
      if (typeof data === "string") {
        // 'Blob' must be from 'global' (i.e. not imported) as we're in a browser context here, so is globally available.
        return {
          type: "Blob",
          value: new Blob([data], {
            type: this.stringMimeType
          })
        };
      }
      if (data.byteLength !== undefined) {
        return {
          type: "ArrayBuffer",
          value: data
        };
      }
      if (data.size !== undefined) {
        return {
          type: "Blob",
          value: data
        };
      }
      throw new Error("Unsupported type for 'data' parameter. Please provide a String, Blob, ArrayBuffer, or File object (from a file input element).");
    }
  }, {
    key: "getPreUploadInfoPartial",
    value: function getPreUploadInfoPartial(_request, data) {
      switch (data.type) {
        case "Blob":
          return this.getBlobInfo(data);
        case "ArrayBuffer":
          return {
            mime: undefined,
            size: data.value.byteLength,
            originalFileName: undefined,
            maxConcurrentUploadParts: undefined
          };
        default:
          assertUnreachable(data);
      }
    }
  }, {
    key: "preUpload",
    value: function preUpload(_source) {
      return undefined;
    }
  }, {
    key: "postUpload",
    value: function postUpload(_init) {
      return UploadManagerBrowserWorkerBase_await();
    } // NO-OP.
  }, {
    key: "getRequestBody",
    value: function getRequestBody(part, blob) {
      return part.range.inclusiveEnd === -1 ? new Blob() : blob.value.slice(part.range.inclusiveStart, part.range.inclusiveEnd + 1);
    }
  }]);
  return UploadManagerBrowserWorkerBase;
}(UploadManagerBase);
;// CONCATENATED MODULE: ./src/public/browser/UploadManagerBrowser.ts
function UploadManagerBrowser_typeof(obj) { "@babel/helpers - typeof"; return UploadManagerBrowser_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, UploadManagerBrowser_typeof(obj); }
function UploadManagerBrowser_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadManagerBrowser_rethrow(thrown, value) {
  if (thrown) throw value;
  return value;
}
function UploadManagerBrowser_finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }
  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }
  return finalizer(false, result);
}
function UploadManagerBrowser_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadManagerBrowser_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadManagerBrowser_toPropertyKey(descriptor.key), descriptor); } }
function UploadManagerBrowser_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadManagerBrowser_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadManagerBrowser_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadManagerBrowser_toPropertyKey(arg) { var key = UploadManagerBrowser_toPrimitive(arg, "string"); return UploadManagerBrowser_typeof(key) === "symbol" ? key : String(key); }
function UploadManagerBrowser_toPrimitive(input, hint) { if (UploadManagerBrowser_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (UploadManagerBrowser_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function UploadManagerBrowser_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) UploadManagerBrowser_setPrototypeOf(subClass, superClass); }
function UploadManagerBrowser_setPrototypeOf(o, p) { UploadManagerBrowser_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return UploadManagerBrowser_setPrototypeOf(o, p); }
function UploadManagerBrowser_createSuper(Derived) { var hasNativeReflectConstruct = UploadManagerBrowser_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = UploadManagerBrowser_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = UploadManagerBrowser_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return UploadManagerBrowser_possibleConstructorReturn(this, result); }; }
function UploadManagerBrowser_possibleConstructorReturn(self, call) { if (call && (UploadManagerBrowser_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return UploadManagerBrowser_assertThisInitialized(self); }
function UploadManagerBrowser_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function UploadManagerBrowser_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function UploadManagerBrowser_getPrototypeOf(o) { UploadManagerBrowser_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return UploadManagerBrowser_getPrototypeOf(o); }


var UploadManager = /*#__PURE__*/function (_UploadManagerBrowser) {
  UploadManagerBrowser_inherits(UploadManager, _UploadManagerBrowser);
  var _super = UploadManagerBrowser_createSuper(UploadManager);
  function UploadManager() {
    UploadManagerBrowser_classCallCheck(this, UploadManager);
    return _super.apply(this, arguments);
  }
  UploadManagerBrowser_createClass(UploadManager, [{
    key: "doPutUploadPart",
    value: function doPutUploadPart(part, _contentLength, source, onProgress, addCancellationHandler) {
      try {
        var _this2 = this;
        var xhr = new XMLHttpRequest();
        var pending = true;
        addCancellationHandler(function () {
          if (pending) {
            xhr.abort();
          }
        });
        return UploadManagerBrowser_finallyRethrows(function () {
          return UploadManagerBrowser_await(new Promise(function (resolve, reject) {
            xhr.upload.addEventListener("progress", function (evt) {
              if (evt.lengthComputable) {
                onProgress(evt.loaded);
              }
            }, false);
            xhr.addEventListener("load", function () {
              var _a;
              var etag = (_a = xhr.getResponseHeader("etag")) !== null && _a !== void 0 ? _a : undefined;
              resolve({
                etag: etag,
                status: xhr.status
              });
            });
            xhr.onabort = function () {
              return reject(new CancelledError());
            };
            xhr.onerror = function () {
              return reject(new Error("File upload error."));
            };
            xhr.ontimeout = function () {
              return reject(new Error("File upload timeout."));
            };
            xhr.open("PUT", part.uploadUrl);
            xhr.send(_this2.getRequestBody(part, source));
          }));
        }, function (_wasThrown, _result) {
          pending = false;
          return UploadManagerBrowser_rethrow(_wasThrown, _result);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return UploadManager;
}(UploadManagerBrowserWorkerBase);
;// CONCATENATED MODULE: ./src/private/ServiceWorkerUtils.ts
function ServiceWorkerUtils_typeof(obj) { "@babel/helpers - typeof"; return ServiceWorkerUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ServiceWorkerUtils_typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = ServiceWorkerUtils_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function ServiceWorkerUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ServiceWorkerUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ServiceWorkerUtils_arrayLikeToArray(o, minLen); }
function ServiceWorkerUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function ServiceWorkerUtils_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function ServiceWorkerUtils_catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function ServiceWorkerUtils_invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function ServiceWorkerUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function ServiceWorkerUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ServiceWorkerUtils_toPropertyKey(descriptor.key), descriptor); } }
function ServiceWorkerUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) ServiceWorkerUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) ServiceWorkerUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function ServiceWorkerUtils_toPropertyKey(arg) { var key = ServiceWorkerUtils_toPrimitive(arg, "string"); return ServiceWorkerUtils_typeof(key) === "symbol" ? key : String(key); }
function ServiceWorkerUtils_toPrimitive(input, hint) { if (ServiceWorkerUtils_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ServiceWorkerUtils_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

var ServiceWorkerUtils = /*#__PURE__*/function () {
  function ServiceWorkerUtils() {
    ServiceWorkerUtils_classCallCheck(this, ServiceWorkerUtils);
  }
  ServiceWorkerUtils_createClass(ServiceWorkerUtils, [{
    key: "canUseServiceWorkers",
    value: function canUseServiceWorkers() {
      return "serviceWorker" in navigator;
    }
  }, {
    key: "sendMessage",
    value: function sendMessage(message, config, serviceWorkerScriptFieldName) {
      try {
        var _this2 = this;
        return ServiceWorkerUtils_await(config.serviceWorkerScope !== undefined ? _this2.getActiveServiceWorkerElseRegister(config, message) : _this2.registerServiceWorkerValidated(config.serviceWorkerScript, message, serviceWorkerScriptFieldName), function (result) {
          if (!result.messageSent) {
            result.serviceWorker.postMessage(message);
          }
          return result.config;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "registerServiceWorkerValidated",
    value: function registerServiceWorkerValidated(serviceWorkerScript, init, serviceWorkerScriptFieldName) {
      try {
        var _this4 = this;
        if (!serviceWorkerScript.startsWith("/")) {
          throw new Error("The '".concat(serviceWorkerScriptFieldName, "' field must start with a '/' and reference a script at the root of your website."));
        }
        var forwardSlashCount = serviceWorkerScript.split("/").length - 1;
        if (forwardSlashCount > 1) {
          ConsoleUtils.warn("The '".concat(serviceWorkerScriptFieldName, "' field should be a root script (e.g. '/script.js'). The Bytescale SDK can only authorize requests originating from webpages that are at the same level as the script or below."));
        }
        return ServiceWorkerUtils_await(_this4.registerServiceWorker(serviceWorkerScript, init));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getActiveServiceWorkerElseRegister",
    value: function getActiveServiceWorkerElseRegister(config, init) {
      try {
        var _this6 = this;
        return ServiceWorkerUtils_await(_this6.getActiveServiceWorker(config.serviceWorkerScope), function (serviceWorker) {
          return serviceWorker !== undefined ? {
            serviceWorker: serviceWorker,
            messageSent: false,
            config: config
          } : ServiceWorkerUtils_await(_this6.registerServiceWorker(config.serviceWorkerScript, init));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Idempotent.
     *
     * Only returns once the service worker has been activated.
     *
     * We don't need to unregister it: we just need to clear the config when auth ends.
     */
  }, {
    key: "registerServiceWorker",
    value: function registerServiceWorker(serviceWorkerScript, init) {
      try {
        var _this8 = this;
        return ServiceWorkerUtils_catch(function () {
          return ServiceWorkerUtils_await(navigator.serviceWorker.register(serviceWorkerScript), function (registration) {
            return ServiceWorkerUtils_await(_this8.waitForActiveServiceWorker(registration, init), function (_ref) {
              var serviceWorker = _ref.serviceWorker,
                messageSent = _ref.messageSent;
              return {
                serviceWorker: serviceWorker,
                messageSent: messageSent,
                config: {
                  serviceWorkerScript: serviceWorkerScript,
                  serviceWorkerScope: registration.scope
                }
              };
            });
          });
        }, function (e) {
          throw new Error("Failed to install Bytescale Service Worker (SW). ".concat(e.name, ": ").concat(e.message));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "waitForActiveServiceWorker",
    value: function waitForActiveServiceWorker(registration, init) {
      try {
        var _exit2 = false;
        // We must check the 'installing' state before the 'active' state (see comment below).
        // The state will be 'installing' when the service worker is installed for the first time, or if there have been
        // code changes to the service worker, else the state will be 'active'.
        var installing = registration.installing;
        return ServiceWorkerUtils_invoke(function () {
          if (installing !== null) {
            var waitForActive = new Promise(function (resolve) {
              var stateChangeHandler = function stateChangeHandler(e) {
                var sw = e.target;
                if (sw.state === "activated") {
                  installing.removeEventListener("statechange", stateChangeHandler);
                  resolve({
                    messageSent: true,
                    serviceWorker: sw
                  });
                }
              };
              installing.addEventListener("statechange", stateChangeHandler);
            });
            installing.postMessage(init);
            _exit2 = true;
            return ServiceWorkerUtils_await(waitForActive);
          }
        }, function (_result) {
          if (_exit2) return _result;
          // We must check the 'installing' state before the 'active' state, because if we've just installed a new service
          // worker, then the new service worker will be in the 'installing' slot whereas the old service worker will be in
          // the 'active' slot. So, if we checked this first, we would always return the old service worker, and therefore the
          // new service worker would never be initialized.
          if (registration.active !== null) {
            return {
              serviceWorker: registration.active,
              messageSent: false
            };
          }
          // We expect the service worker to use 'skipWaiting', so we don't expect 'waiting' service workers.
          throw new Error("Service worker was neither 'installing' or 'active'.");
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getActiveServiceWorker",
    value: function getActiveServiceWorker(serviceWorkerScope) {
      try {
        return ServiceWorkerUtils_await(navigator.serviceWorker.getRegistrations(), function (registrations) {
          var _iterator = _createForOfIteratorHelper(registrations),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var registration = _step.value;
              if (registration.active !== null && registration.scope === serviceWorkerScope) {
                return registration.active;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return undefined;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return ServiceWorkerUtils;
}();
;// CONCATENATED MODULE: ./src/public/browser/AuthManagerBrowser.ts
function AuthManagerBrowser_typeof(obj) { "@babel/helpers - typeof"; return AuthManagerBrowser_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AuthManagerBrowser_typeof(obj); }
function AuthManagerBrowser_defineProperty(obj, key, value) { key = AuthManagerBrowser_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function AuthManagerBrowser_empty() {}
function AuthManagerBrowser_awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(AuthManagerBrowser_empty) : Promise.resolve();
  }
}
function AuthManagerBrowser_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function AuthManagerBrowser_async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function AuthManagerBrowser_invokeIgnored(body) {
  var result = body();
  if (result && result.then) {
    return result.then(AuthManagerBrowser_empty);
  }
}
function AuthManagerBrowser_invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function AuthManagerBrowser_catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function AuthManagerBrowser_rethrow(thrown, value) {
  if (thrown) throw value;
  return value;
}
function AuthManagerBrowser_finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }
  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }
  return finalizer(false, result);
}
function AuthManagerBrowser_continueIgnored(value) {
  if (value && value.then) {
    return value.then(AuthManagerBrowser_empty);
  }
}
function AuthManagerBrowser_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function AuthManagerBrowser_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, AuthManagerBrowser_toPropertyKey(descriptor.key), descriptor); } }
function AuthManagerBrowser_createClass(Constructor, protoProps, staticProps) { if (protoProps) AuthManagerBrowser_defineProperties(Constructor.prototype, protoProps); if (staticProps) AuthManagerBrowser_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function AuthManagerBrowser_toPropertyKey(arg) { var key = AuthManagerBrowser_toPrimitive(arg, "string"); return AuthManagerBrowser_typeof(key) === "symbol" ? key : String(key); }
function AuthManagerBrowser_toPrimitive(input, hint) { if (AuthManagerBrowser_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (AuthManagerBrowser_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }




var AuthManagerImpl = /*#__PURE__*/function () {
  function AuthManagerImpl(serviceWorkerUtils) {
    AuthManagerBrowser_classCallCheck(this, AuthManagerImpl);
    this.serviceWorkerUtils = serviceWorkerUtils;
    this.serviceWorkerScriptFieldName = "serviceWorkerScript";
    this.contentType = "content-type";
    this.contentTypeJson = "application/json";
    this.contentTypeText = "text/plain";
    this.minJwtTtlSeconds = 10;
    this.maxJwtTtlSeconds = 2147483; // Max value for window.setTimeout is 2147483647ms -- if we go over this, the timeout fires immediately.
    this.retryAuthAfterErrorSeconds = 5;
    this.refreshBeforeExpirySeconds = 20;
    this.authSessionMutex = AuthSessionState.getMutex();
  }
  AuthManagerBrowser_createClass(AuthManagerImpl, [{
    key: "isAuthSessionActive",
    value: function isAuthSessionActive() {
      return AuthSessionState.getSession() !== undefined;
    }
  }, {
    key: "beginAuthSession",
    value: function beginAuthSession(params) {
      try {
        var _this2 = this;
        return AuthManagerBrowser_await(_this2.authSessionMutex.safe(AuthManagerBrowser_async(function () {
          // We check both 'session' and 'sessionDisposing' here, as we don't want to call 'beginAuthSession' until the session is fully disposed.
          if (_this2.isAuthSessionActive()) {
            throw new Error("Auth session already active. Please call 'await endAuthSession()' and then call 'await beginAuthSession(...)' to start a new auth session.");
          }
          var newSession = {
            accessToken: undefined,
            accessTokenRefreshHandle: undefined,
            params: params,
            isActive: true,
            authServiceWorker: params.serviceWorkerScript !== undefined && _this2.serviceWorkerUtils.canUseServiceWorkers() ? {
              serviceWorkerScript: params.serviceWorkerScript,
              serviceWorkerScope: undefined
            } : undefined
          };
          AuthSessionState.setSession(newSession);
          return newSession;
        })), function (session) {
          // IMPORTANT: must be called outside the above, else re-entrant deadlock will occur.
          return AuthManagerBrowser_awaitIgnored(_this2.refreshAccessToken(session));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "endAuthSession",
    value: function endAuthSession() {
      try {
        var _this4 = this;
        return AuthManagerBrowser_awaitIgnored(_this4.authSessionMutex.safe(AuthManagerBrowser_async(function () {
          var session = AuthSessionState.getSession();
          if (session === undefined) {
            return;
          }
          AuthSessionState.setSession(undefined);
          session.isActive = false;
          if (session.accessTokenRefreshHandle !== undefined) {
            clearTimeout(session.accessTokenRefreshHandle);
          }
          return AuthManagerBrowser_await(_this4.deleteAccessToken(session.params), function () {
            return AuthManagerBrowser_invokeIgnored(function () {
              if (session.authServiceWorker !== undefined) {
                // Prevent service worker from authorizing subsequent requests.
                return AuthManagerBrowser_awaitIgnored(_this4.serviceWorkerUtils.sendMessage({
                  type: "SET_BYTESCALE_AUTH_CONFIG",
                  config: []
                }, session.authServiceWorker, _this4.serviceWorkerScriptFieldName));
              }
            });
          });
        })));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "refreshAccessToken",
    value: function refreshAccessToken(session) {
      try {
        var _this6 = this;
        return AuthManagerBrowser_awaitIgnored(_this6.authSessionMutex.safe(AuthManagerBrowser_async(function () {
          if (!session.isActive) {
            return;
          }
          var timeout = _this6.retryAuthAfterErrorSeconds;
          return AuthManagerBrowser_continueIgnored(AuthManagerBrowser_finallyRethrows(function () {
            return AuthManagerBrowser_catch(function () {
              var _getAccessToken = _this6.getAccessToken,
                _session$params = session.params;
              return AuthManagerBrowser_await(session.params.authHeaders(), function (_session$params$authH) {
                return AuthManagerBrowser_await(_getAccessToken.call(_this6, _session$params, _session$params$authH), function (jwt) {
                  // We don't use cookie-based auth if the browser supports service worker-based auth, as using both will cause
                  // confusion for us in the future (i.e. we may question "do we need to use both together? was there a reason?").
                  // Also: if the user has omitted "allowedOrigins" from their JWT, then service worker-based auth is more secure
                  // than cookie-based auth, which is another reason to prevent these cookies from being set unless required.
                  var setCookie = session.authServiceWorker === undefined;
                  return AuthManagerBrowser_await(_this6.setAccessToken(session.params, jwt, setCookie), function (setTokenResult) {
                    return AuthManagerBrowser_invoke(function () {
                      if (session.authServiceWorker !== undefined) {
                        return AuthManagerBrowser_awaitIgnored(_this6.serviceWorkerUtils.sendMessage({
                          type: "SET_BYTESCALE_AUTH_CONFIG",
                          config: [{
                            headers: [{
                              key: "Authorization",
                              value: "Bearer ".concat(jwt)
                            }],
                            expires: Date.now() + setTokenResult.ttlSeconds * 1000,
                            urlPrefix: "".concat(_this6.getCdnUrl(session.params), "/").concat(session.params.accountId, "/")
                          }]
                        }, session.authServiceWorker, _this6.serviceWorkerScriptFieldName));
                      }
                    }, function () {
                      var desiredTtl = setTokenResult.ttlSeconds - _this6.refreshBeforeExpirySeconds;
                      timeout = Math.max(desiredTtl, _this6.minJwtTtlSeconds);
                      if (desiredTtl !== timeout) {
                        ConsoleUtils.warn("JWT expiration is too short: waiting for ".concat(timeout, " seconds before refreshing."));
                      }
                      // There's no need to print a warning for this: it's OK to silently request the JWT before it expires. Also, this is 24 days in this case!
                      timeout = Math.min(timeout, _this6.maxJwtTtlSeconds);
                      session.accessToken = setTokenResult.accessToken;
                    });
                  });
                });
              });
            }, function (e) {
              // Use 'warn' instead of 'error' since this happens frequently, i.e. user goes through a tunnel, and some customers report these errors to systems like Sentry, so we don't want to spam.
              ConsoleUtils.warn("Unable to refresh JWT access token: ".concat(e));
            });
          }, function (_wasThrown, _result) {
            session.accessTokenRefreshHandle = window.setTimeout(function () {
              _this6.refreshAccessToken(session).then(function () {},
              // Should not occur, as this method shouldn't throw errors.
              function (e) {
                return ConsoleUtils.error("Unexpected error when refreshing JWT access token: ".concat(e));
              });
            }, timeout * 1000);
            return AuthManagerBrowser_rethrow(_wasThrown, _result);
          }));
        })));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getAccessTokenUrl",
    value: function getAccessTokenUrl(params, setCookie) {
      return "".concat(this.getCdnUrl(params), "/api/v1/access_tokens/").concat(params.accountId, "?set-cookie=").concat(setCookie ? "true" : "false");
    }
  }, {
    key: "getCdnUrl",
    value: function getCdnUrl(params) {
      var _a;
      return BytescaleApiClientConfigUtils.getCdnUrl((_a = params.options) !== null && _a !== void 0 ? _a : {});
    }
  }, {
    key: "deleteAccessToken",
    value: function deleteAccessToken(params) {
      try {
        var _this8 = this;
        var _a;
        return AuthManagerBrowser_awaitIgnored(BaseAPI.fetch(_this8.getAccessTokenUrl(params, true), {
          method: "DELETE",
          credentials: "include",
          headers: {}
        }, {
          isBytescaleApi: true,
          fetchApi: (_a = params.options) === null || _a === void 0 ? void 0 : _a.fetchApi
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "setAccessToken",
    value: function setAccessToken(params, jwt, setCookie) {
      try {
        var _this10 = this;
        var _a;
        var request = {
          accessToken: jwt
        };
        return AuthManagerBrowser_await(BaseAPI.fetch(_this10.getAccessTokenUrl(params, setCookie), {
          method: "PUT",
          credentials: "include",
          headers: AuthManagerBrowser_defineProperty({}, _this10.contentType, _this10.contentTypeJson),
          body: JSON.stringify(request)
        }, {
          isBytescaleApi: true,
          fetchApi: (_a = params.options) === null || _a === void 0 ? void 0 : _a.fetchApi
        }), function (response) {
          return AuthManagerBrowser_await(response.json());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "getAccessToken",
    value: function getAccessToken(params, headers) {
      try {
        var _this12 = this;
        var _a, _b;
        var endpointName = "Your auth API endpoint";
        var requiredContentType = _this12.contentTypeText;
        return AuthManagerBrowser_await(BaseAPI.fetch(params.authUrl, {
          method: "GET",
          headers: headers
        }, {
          isBytescaleApi: false,
          fetchApi: (_a = params.options) === null || _a === void 0 ? void 0 : _a.fetchApi
        }), function (result) {
          var actualContentType = (_b = result.headers.get(_this12.contentType)) !== null && _b !== void 0 ? _b : "";
          // Support content types like "text/plain; charset=utf-8" and "text/plain"
          if (actualContentType.split(";")[0] !== requiredContentType) {
            throw new Error("".concat(endpointName, " returned \"").concat(actualContentType, "\" for the ").concat(_this12.contentType, " response header, but the Bytescale SDK requires \"").concat(requiredContentType, "\"."));
          }
          return AuthManagerBrowser_await(result.text(), function (jwt) {
            if (jwt.length === 0) {
              throw new Error("".concat(endpointName, " returned an empty string. Please return a valid JWT instead."));
            }
            if (jwt.trim().length !== jwt.length) {
              // Whitespace can be a nightmare to spot/debug, so we fail early here.
              throw new Error("".concat(endpointName, " returned whitespace around the JWT, please remove it."));
            }
            return jwt;
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return AuthManagerImpl;
}();
/**
 * Alternative way of implementing a static class (i.e. all methods static). We do this so we can use a interface on the class (interfaces can't define static methods).
 */
var AuthManager = new AuthManagerImpl(new ServiceWorkerUtils());
;// CONCATENATED MODULE: ./src/public/browser/index.ts


;// CONCATENATED MODULE: ./src/index.browser.ts
/* tslint:disable */
/* eslint-disable */


var __lib_exports__AuthManager = __lib_exports__.AuthManager;
var __lib_exports__BaseAPI = __lib_exports__.BaseAPI;
var __lib_exports__BinaryResult = __lib_exports__.BinaryResult;
var __lib_exports__BytescaleApiClientConfigUtils = __lib_exports__.BytescaleApiClientConfigUtils;
var __lib_exports__BytescaleApiError = __lib_exports__.BytescaleApiError;
var __lib_exports__BytescaleGenericError = __lib_exports__.BytescaleGenericError;
var __lib_exports__CancelledError = __lib_exports__.CancelledError;
var __lib_exports__CommonTypesNoOp = __lib_exports__.CommonTypesNoOp;
var __lib_exports__FileApi = __lib_exports__.FileApi;
var __lib_exports__FolderApi = __lib_exports__.FolderApi;
var __lib_exports__JSONApiResponse = __lib_exports__.JSONApiResponse;
var __lib_exports__JobApi = __lib_exports__.JobApi;
var __lib_exports__UploadApi = __lib_exports__.UploadApi;
var __lib_exports__UploadManager = __lib_exports__.UploadManager;
var __lib_exports__UrlBuilder = __lib_exports__.UrlBuilder;
var __lib_exports__UrlBuilderTypesNoOp = __lib_exports__.UrlBuilderTypesNoOp;
var __lib_exports__VoidApiResponse = __lib_exports__.VoidApiResponse;
var __lib_exports__encodeBytescaleQuerystringKVP = __lib_exports__.encodeBytescaleQuerystringKVP;
var __lib_exports__querystring = __lib_exports__.querystring;
export { __lib_exports__AuthManager as AuthManager, __lib_exports__BaseAPI as BaseAPI, __lib_exports__BinaryResult as BinaryResult, __lib_exports__BytescaleApiClientConfigUtils as BytescaleApiClientConfigUtils, __lib_exports__BytescaleApiError as BytescaleApiError, __lib_exports__BytescaleGenericError as BytescaleGenericError, __lib_exports__CancelledError as CancelledError, __lib_exports__CommonTypesNoOp as CommonTypesNoOp, __lib_exports__FileApi as FileApi, __lib_exports__FolderApi as FolderApi, __lib_exports__JSONApiResponse as JSONApiResponse, __lib_exports__JobApi as JobApi, __lib_exports__UploadApi as UploadApi, __lib_exports__UploadManager as UploadManager, __lib_exports__UrlBuilder as UrlBuilder, __lib_exports__UrlBuilderTypesNoOp as UrlBuilderTypesNoOp, __lib_exports__VoidApiResponse as VoidApiResponse, __lib_exports__encodeBytescaleQuerystringKVP as encodeBytescaleQuerystringKVP, __lib_exports__querystring as querystring };
